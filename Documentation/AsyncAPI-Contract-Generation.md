# AsyncAPI Contract Generation Guide

## Overview

This guide explains how to generate C# contract types from AsyncAPI YAML specifications for our retail microservices architecture. The AsyncAPI specification provides a structured way to define message contracts, and we can automatically generate strongly-typed C# models from these definitions.

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [Contract Generation Process](#contract-generation-process)
3. [Generated Contract Structure](#generated-contract-structure)
4. [Integration with Microservices](#integration-with-microservices)
5. [Best Practices](#best-practices)
6. [Troubleshooting](#troubleshooting)

## Prerequisites

### 1. Node.js and npm
Download and install from [nodejs.org](https://nodejs.org/).

Check the installation:
```bash
node -v
npm -v
```
You should see version numbers like v18.x or higher.

### 2. AsyncAPI Generator
Install the official generator:
```bash
npm install -g @asyncapi/generator@2.0.0
```

Check the installation:
```bash
asyncapi-generator --version
```
You should see: `2.0.0`

## Contract Generation Process

### Step 1: Generate Contracts for All Services

Run these commands to generate C# contracts for all microservices:

```bash
# Retail Customers Service
asyncapi-generator "C:\Users\AatishAgarwal\source\repos\SampleMicroservice.Net8\Contracts\AsyncAPI\Retail-Customers-AsyncAPI-v1.0.0.yaml" @lagoni/asyncapi-quicktype-template@1.0.2 -o "C:\Users\AatishAgarwal\source\repos\SampleMicroservice.Net8\Retail.Customers\src\CleanArchitecture.Contracts" -p quicktypeLanguage=csharp

# Retail Orders Read Service
asyncapi-generator "C:\Users\AatishAgarwal\source\repos\SampleMicroservice.Net8\Contracts\AsyncAPI\Retail-Orders-Read-AsyncAPI-v1.0.0.yaml" @lagoni/asyncapi-quicktype-template@1.0.2 -o "C:\Users\AatishAgarwal\source\repos\SampleMicroservice.Net8\Retail.Orders.Read\src\CleanArchitecture.Contracts" -p quicktypeLanguage=csharp

# Retail Orders Write Service
asyncapi-generator "C:\Users\AatishAgarwal\source\repos\SampleMicroservice.Net8\Contracts\AsyncAPI\Retail-Orders-Write-AsyncAPI-v1.0.0.yaml" @lagoni/asyncapi-quicktype-template@1.0.2 -o "C:\Users\AatishAgarwal\source\repos\SampleMicroservice.Net8\Retail.Orders.Write\src\CleanArchitecture.Contracts" -p quicktypeLanguage=csharp

# Retail Products Service
asyncapi-generator "C:\Users\AatishAgarwal\source\repos\SampleMicroservice.Net8\Contracts\AsyncAPI\Retail-Products-AsyncAPI-v1.0.0.yaml" @lagoni/asyncapi-quicktype-template@1.0.2 -o "C:\Users\AatishAgarwal\source\repos\SampleMicroservice.Net8\Retail.Products\src\CleanArchitecture.Contracts" -p quicktypeLanguage=csharp
```

### Step 2: Verify Generated Files

After generation, you should see the following structure in each service:

```
Retail.Customers/src/CleanArchitecture.Contracts/
├── InventoryUpdatedEvent.cs
├── LineItem.cs
└── [other generated files]

Retail.Orders.Read/src/CleanArchitecture.Contracts/
├── InventoryUpdatedEvent.cs
├── LineItem.cs
└── [other generated files]

Retail.Orders.Write/src/CleanArchitecture.Contracts/
├── OrderCreatedEvent.cs
├── OrderUpdatedEvent.cs
├── OrderCancelledEvent.cs
├── OrderCompletedEvent.cs
├── OrderItem.cs
├── Address.cs
└── [other generated files]

Retail.Products/src/CleanArchitecture.Contracts/
├── OrderCreatedEvent.cs
├── InventoryUpdatedEvent.cs
├── InventoryErrorEvent.cs
├── LineItem.cs
└── [other generated files]
```

## Generated Contract Structure

### Example Generated C# Class

```csharp
// <auto-generated />
// To parse this JSON data:
// var inventoryEvent = InventoryUpdatedEvent.FromJson(jsonString);
namespace InventoryUpdatedEventNamespace
{
    using Newtonsoft.Json;
    using System;
    using System.Collections.Generic;

    public partial class InventoryUpdatedEvent
    {
        [JsonProperty("customerId")]
        public Guid CustomerId { get; set; }

        [JsonProperty("orderId")]
        public Guid OrderId { get; set; }

        [JsonProperty("orderDate")]
        public DateTime OrderDate { get; set; }

        [JsonProperty("totalAmount")]
        public decimal TotalAmount { get; set; }

        [JsonProperty("lineItems")]
        public List<LineItem> LineItems { get; set; }
    }

    public partial class InventoryUpdatedEvent
    {
        public static InventoryUpdatedEvent FromJson(string json) =>
            JsonConvert.DeserializeObject<InventoryUpdatedEvent>(json);
    }

    public static class Serialize
    {
        public static string ToJson(this InventoryUpdatedEvent self) =>
            JsonConvert.SerializeObject(self);
    }
}
```

### Key Features of Generated Contracts

1. **Strongly Typed**: All properties are properly typed (Guid, DateTime, decimal, etc.)
2. **JSON Serialization**: Built-in Newtonsoft.Json serialization support
3. **Validation**: Required fields and constraints from AsyncAPI schema
4. **Documentation**: XML comments from AsyncAPI descriptions
5. **Namespace Isolation**: Each service has its own contract namespace

## Integration with Microservices

### 1. Project References

Add the generated contract projects to your microservice projects:

```xml
<ProjectReference Include="src\CleanArchitecture.Contracts\Retail.Customers.Contracts.csproj" />
```

### 2. Using Generated Contracts

#### Publishing Events (Orders Write Service)
```csharp
using Retail.Orders.Write.Contracts;

public class OrderService
{
    public async Task CreateOrderAsync(CreateOrderRequest request)
    {
        // Business logic...
        
        var orderCreatedEvent = new OrderCreatedEvent
        {
            EventId = Guid.NewGuid(),
            EventType = "OrderCreated",
            Timestamp = DateTime.UtcNow,
            OrderId = order.Id,
            CustomerId = order.CustomerId,
            OrderItems = order.Items.Select(i => new OrderItem
            {
                ProductId = i.ProductId,
                Quantity = i.Quantity,
                UnitPrice = i.UnitPrice,
                TotalPrice = i.TotalPrice
            }).ToList(),
            TotalAmount = order.TotalAmount,
            ShippingAddress = new Address
            {
                Street = order.ShippingAddress.Street,
                City = order.ShippingAddress.City,
                State = order.ShippingAddress.State,
                ZipCode = order.ShippingAddress.ZipCode,
                Country = order.ShippingAddress.Country
            }
        };

        // Publish to message broker
        await _messagePublisher.PublishAsync(orderCreatedEvent);
    }
}
```

#### Consuming Events (Products Service)
```csharp
using Retail.Products.Contracts;

public class InventoryService
{
    public async Task HandleOrderCreatedAsync(OrderCreatedEvent orderEvent)
    {
        try
        {
            // Process inventory for the order
            await ProcessInventoryAsync(orderEvent);
            
            // Publish inventory updated event
            var inventoryUpdatedEvent = new InventoryUpdatedEvent
            {
                CustomerId = orderEvent.CustomerId,
                OrderId = orderEvent.OrderId,
                OrderDate = orderEvent.Timestamp,
                TotalAmount = orderEvent.TotalAmount,
                LineItems = orderEvent.OrderItems.Select(i => new LineItem
                {
                    SkuId = i.ProductId,
                    Qty = i.Quantity,
                    UnitPrice = i.UnitPrice,
                    TotalPrice = i.TotalPrice
                }).ToList()
            };

            await _messagePublisher.PublishAsync(inventoryUpdatedEvent);
        }
        catch (Exception ex)
        {
            // Publish error event
            var errorEvent = new InventoryErrorEvent
            {
                CustomerId = orderEvent.CustomerId,
                OrderId = orderEvent.OrderId,
                OrderDate = orderEvent.Timestamp,
                TotalAmount = orderEvent.TotalAmount,
                ErrorMessage = ex.Message
            };

            await _messagePublisher.PublishAsync(errorEvent);
        }
    }
}
```

## Best Practices

### 1. Contract Versioning
- Use semantic versioning for AsyncAPI specifications
- Maintain backward compatibility when possible
- Document breaking changes clearly

### 2. Schema Evolution
- Add new optional fields rather than removing existing ones
- Use `additionalProperties: true` for extensibility when appropriate
- Validate schema changes against all consumers

### 3. Error Handling
- Always include error events in your AsyncAPI specifications
- Use consistent error message structures across services
- Implement proper retry and dead letter queue handling

### 4. Documentation
- Keep AsyncAPI YAML files as the single source of truth
- Update documentation when contracts change
- Use descriptive field names and descriptions

### 5. Testing
- Generate contracts as part of your CI/CD pipeline
- Validate generated contracts against test data
- Use contract testing to verify compatibility between services

## Troubleshooting

### Common Issues

1. **Node.js Not Found**: Install Node.js from https://nodejs.org/
2. **AsyncAPI Generator Not Found**: Run `npm install -g @asyncapi/generator@2.0.0`
3. **Permission Errors**: Run command prompt as Administrator
4. **Template Errors**: Ensure AsyncAPI YAML files are valid

### Validation

Validate AsyncAPI YAML files before generation:
```bash
npx @asyncapi/cli validate Contracts/AsyncAPI/Retail-Customers-AsyncAPI-v1.0.0.yaml
```

## References

- [AsyncAPI Generator on npm](https://www.npmjs.com/package/@asyncapi/generator)
- [Quicktype Template (GitHub)](https://github.com/lagoni/asyncapi-quicktype-template)
- [AsyncAPI Studio (Online Editor)](https://studio.asyncapi.com/)
- [AsyncAPI Specification](https://www.asyncapi.com/docs/specifications/v2.0.0)
